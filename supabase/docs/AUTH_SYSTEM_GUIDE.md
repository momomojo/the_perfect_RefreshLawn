# RefreshLawn Authentication System Guide

This guide provides a complete overview of the role-based authentication system implemented in RefreshLawn.

## Overview

RefreshLawn uses Supabase for authentication with a custom JWT-based role system that enables:

1. User authentication (signup, signin, password reset)
2. Role-based access control with three roles: `admin`, `technician`, and `customer`
3. JWT claims that include the user's role for efficient authorization checks
4. Row Level Security (RLS) policies that enforce permissions at the database level

## Role Storage Architecture

The system stores user roles in multiple locations for redundancy and compatibility:

1. **Primary: `user_roles` table** - The official Supabase approach with a separate table
2. **Secondary: `profiles` table** - For backward compatibility and profile information
3. **JWT Claims** - Roles are added to JWT tokens via a custom access token hook
4. **User Metadata** - Roles are stored in both `raw_user_meta_data` and `raw_app_meta_data`

All these locations are kept in sync via database triggers and functions.

## Role-Based Access Control (RBAC)

### Available Roles

| Role         | Description                 | Permissions                                    |
| ------------ | --------------------------- | ---------------------------------------------- |
| `admin`      | System administrators       | Full access to all resources                   |
| `technician` | Lawn care service providers | View assigned bookings, update booking status  |
| `customer`   | End users of the service    | Create bookings, view own bookings and profile |

### RLS Policy Functions

The following helper functions are used in RLS policies:

- `auth.is_admin()` - Checks if user has admin role
- `auth.is_technician()` - Checks if user has technician role
- `auth.is_customer()` - Checks if user has customer role
- `auth.is_role_admin()` - Direct JWT check for admin role
- `auth.is_role_technician()` - Direct JWT check for technician role
- `auth.is_role_customer()` - Direct JWT check for customer role

## Setup Process

### 1. Required Database Tables

```sql
-- The profiles table (contains user profile info and role)
CREATE TABLE IF NOT EXISTS profiles (
  id UUID REFERENCES auth.users ON DELETE CASCADE PRIMARY KEY,
  role TEXT CHECK (role IN ('customer', 'technician', 'admin')),
  -- Other profile fields
);

-- The user_roles table (official Supabase approach)
CREATE TABLE IF NOT EXISTS public.user_roles (
  id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  user_id uuid REFERENCES auth.users ON DELETE CASCADE NOT NULL,
  role app_role NOT NULL,
  UNIQUE (user_id, role)
);
```

### 2. JWT Custom Access Token Hook

A custom hook that adds the user's role to JWT tokens:

```sql
CREATE OR REPLACE FUNCTION public.custom_access_token_hook(event jsonb)
RETURNS jsonb AS $$
DECLARE
  claims jsonb;
  user_role text;
  event_user_id uuid;
BEGIN
  -- Extract the user ID and claims
  event_user_id := (event ->> 'user_id')::uuid;
  claims := event->'claims';

  -- Get user role from user_roles table
  SELECT ur.role::text INTO user_role
  FROM public.user_roles ur
  WHERE ur.user_id = event_user_id
  LIMIT 1;

  -- Fall back to profiles table if needed
  IF user_role IS NULL THEN
    SELECT p.role INTO user_role
    FROM public.profiles p
    WHERE p.id = event_user_id;
  END IF;

  -- Add role to JWT claims
  IF user_role IS NOT NULL THEN
    claims := jsonb_set(claims, '{user_role}', to_jsonb(user_role));

    -- Set in app_metadata without replacing the entire object
    IF claims ? 'app_metadata' THEN
      claims := jsonb_set(claims, '{app_metadata,role}', to_jsonb(user_role));
    ELSE
      claims := jsonb_set(claims, '{app_metadata}', json_build_object('role', user_role)::jsonb);
    END IF;

    -- Update the claims in the event
    event := jsonb_set(event, '{claims}', claims);
  END IF;

  RETURN event;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;
```

### 3. Dashboard Configuration

After deploying migrations, you must enable the JWT hook in the Supabase Dashboard:

1. Go to **Authentication** > **Hooks**
2. For the **JWT Token** event, click **Add Hook**
3. Select **Database Function** as the type
4. Choose `public.custom_access_token_hook` from the dropdown
5. Click **Save**

### 4. Client-Side Role Management

```typescript
// Get user role from JWT
export const getUserRole = async (): Promise<string | null> => {
  const {
    data: { session },
  } = await supabase.auth.getSession();
  if (!session) return null;

  // Check for role in JWT claims
  if (session.access_token) {
    const jwt = jwtDecode(session.access_token);
    const userRole = (jwt as any).user_role || (jwt as any).app_metadata?.role;
    if (userRole) return userRole;
  }

  // Fallback to metadata in session
  return (
    session.user.app_metadata?.role ||
    session.user.user_metadata?.role ||
    "customer"
  );
};

// React hook for using roles in components
export const useUserRole = () => {
  const [role, setRole] = useState<string | null>(null);
  const [isAdmin, setIsAdmin] = useState(false);
  // ...
};
```

## Common Issues and Solutions

| Issue                     | Solution                                                                                                   |
| ------------------------- | ---------------------------------------------------------------------------------------------------------- |
| Role not appearing in JWT | 1. Enable custom access token hook in Dashboard<br>2. User needs to log out and back in to get a new token |
| Inconsistent roles        | Use `fix_user_role_consistency()` function to synchronize roles                                            |
| Permission errors         | 1. Check RLS policies are correct<br>2. Verify user has correct role assigned                              |
| Role not updating         | Call `supabase.auth.refreshSession()` after role changes                                                   |

## Testing and Verification

Use these SQL scripts to test the system:

1. **Test JWT role claims**: `supabase/tests/jwt_role_policies_test.sql`
2. **Test role consistency**: `SELECT * FROM public.check_role_consistency();`

For client-side testing, use the verification function:

```typescript
const { isWorking, missingClaims, message } = await verifyJwtHookWorking();
console.log(message);
```

## Maintenance and Upgrades

When maintaining the system:

1. **Adding a new role**: Update the `app_role` enum type and check constraints
2. **Adding tables**: Always add appropriate RLS policies
3. **Refreshing JWTs**: After schema changes, run `fix_user_role_consistency()` then have users refresh their sessions

## Implementation Journey & Lessons Learned

During the development of this authentication system, we faced several challenges:

1. **JWT Hook Configuration**: Initially, the hook was failing because we were trying to modify required claims. We fixed this by properly preserving all required claims and only adding our custom claims.

2. **Parameter Ambiguity**: Variable names in PL/pgSQL can clash with column names, causing the wrong column to be referenced. We fixed this by using prefixed variable names (e.g., `v_user_id` instead of `user_id`).

3. **Role Storage Consistency**: Storing roles in multiple locations led to synchronization issues. We implemented triggers and fix functions to maintain consistency.

4. **JWT Refresh Logic**: Users needed to get a new JWT after role changes. We added client-side logic to refresh sessions as needed.

These lessons highlight the importance of careful planning when implementing custom authentication systems.
